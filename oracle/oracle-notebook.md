<!-- TOC -->

- [1. 数据类型](#1-数据类型)
    - [1.1 字符类型](#11-字符类型)
    - [1.2 整数类型](#12-整数类型)
    - [1.3 浮点类型](#13-浮点类型)
    - [1.4 bool类型](#14-bool类型)
    - [1.5 sizeof](#15-sizeof)
    - [1.6 类型转换规则](#16-类型转换规则)
- [2. 输入输出缓冲区](#2-输入输出缓冲区)
    - [2.1 输入缓冲区](#21-输入缓冲区)
    - [2.2 输出缓冲区](#22-输出缓冲区)
- [3. 数组](#3-数组)
- [4. 指针](#4-指针)
- [5. 字符串](#5-字符串)
- [6. 结构体](#6-结构体)
- [7. 内存分配](#7-内存分配)
    - [7.1 malloc动态分配内存](#71-malloc动态分配内存)
    - [7.2 free释放内存](#72-free释放内存)
- [8. 文件操作](#8-文件操作)

<!-- /TOC -->
# 1. 数据类型
## 1.1 字符类型 
占1个字节（256）：
1. char，占位符%c（表示字母）或者%hhd（表示数字）
2. unsigned char，占位符%c或者%hhu

## 1.2 整数类型 
1. short，占2个字节（65535），占位符%hd
2. unsigned short，占2个字节（65535），占位符%hu
3. long，占4个字节（2的32次方），占位符%ld
4. unsigned long，占4个字节（2的32次方），占位符%lu
5. int，占4个字节（2的32次方），占位符%d
6. unsigned int，占4个字节（2的32次方），占位符%u

## 1.3 浮点类型 
1. flout，占4个字节（2的32次方），%f（后面的多出0，例如5.20000）或者%g（没有0，例如5.2）
2. double，占8个字节（2的64次方），%lf或者%lg

double是默认浮点类型，要使用flout，需要在数字后面加f。

## 1.4 bool类型 
真为1，假为0

## 1.5 sizeof
返回一个变量类型或者变量的大小，**sizeof()里面的计算不成立。**

## 1.6 类型转换规则 
1. 隐式转换
    - 如果一个表达式中类型不同，计算机会进行隐式转换。
    - 占地小的转换为占地大的。
    - 如果类型一样大，则整数转浮点数，有符号转无符号。
2. 强制转换 
    - 在一个数据前加上()可以实现强制转换，如：(char)10。
    - 强制转换可能造成数据丢失。

# 2. 输入输出缓冲区
## 2.1 输入缓冲区
1. 用户在键盘上输入的内容首先进入输入缓冲区，然后程序从输入缓冲区里拿东西。
2. 先进入输入缓冲区的内容必须先处理。
3. 如果用户输入了错误的数据，就没机会得到后面用户输入的内容了。
4. 以下语句可以删除输入缓冲区里的多余数据：<br>
>scanf("%*[^\n]")<br>
scanf("%*c")

## 2.2 输出缓冲区
以下四种情况下输出缓冲区里的内容才会显示在屏幕上：
1. 输出缓冲区里包含"\n"
2. 程序结束了
3. 输出缓冲区被充满了
4. 使用fflush(stdout)函数强制显示

# 3. 数组
1. 代表内存里一组连续的同类型存储区，要声明类型和个数：<br>
int arr[10]
2. 数组名称代表第一个的存储区地址，即arr等价于&arr[0]，**但是数组名称只能代表地址，不能被赋值。**
3. sizeof()可以计算整个数组的长度。
4. 二维数组 int arr[3][2]，3代表3组，每组有2个存储区。

# 4. 指针
1. 记录地址数据的变量。
2. typedef关键字可以给指针其别名，如：typedef int* p_int，就是把int*类型指针起名字为p_int。
3. 指针必须初始化。
4. 可以用指针指向数组名称，即int *p=arr， *(p+2)代表arr[2]。
5. 声明指针可以使用const关键字：
    - const int* p_num：指针本身可以修改，但不可以通过指针修改配对的普通变量。
    - int* const p_num：指针本身不可以修改，但可以通过它修改配对的普通变量。
6. void*是无类型指针，可以指向任何类型指针，使用前需要先强制类型转换成有类型指针。
7. 二级指针：
    - 可以代表一个指针数组：
    >char *str[]={"abc","def"};<br>
    char **pp_ch = str;<br>
    printf("%s\n", *(pp_ch+num));
    - 作为参数，指向指针的指针，比如要把指针销毁这个操作封装在一个函数中，就需要用到二级指针做参数。
8. 函数指针：
    - 根据函数声明变化得到：
    >void (*p_fun)(void)=NULL;
    - 可以用typedef给函数指针起名字：
    >typedef void (*p_fun)(void);<br>
    p_fun p_add;

# 5. 字符串
1. 一组连续的字符，必须以'\0'结尾，占位符为%s。
2. 不可以用操作符处理字符串，只能用函数。
    - strlen 获得字符串长度
    - strcat/strncat 连接字符串
    - strcpy/strncpy 复制字符串
    - strcmp/strncmp 比较字符串
    - memset 把字符数组中前n个字符设置为同一字符
    - strstr 在一个字符串里查找另一个字符串所在的位置，返回找到的第一个字符的存储地址
    - sprintf 可以把多个数字合成一个字符串
    - sscanf 可以从字符串里获得多个数字并记录到存储区
    - atoi 把字符串里的整数转成整数类型
    - atof 把字符串里的小数转成小数类型
    - fgets 可以从任何文件读字符串
3. char *str[]可以记录多个相关字符串。

# 6. 结构体
1. 创建新数据类型的工具：
>struct pt{int x,y;};
2. typedef可以给结构体取别名：
>typedef struct{int x,y;}pt;
3. 使用.可以获得结构体申明中某部位的存储位置：
>printf((%d,%d),pt1.x,pt1.y);
4. 结构体之间可以直接赋值：
>pt pt1={0,0},pt2={}; pt1=pt2;
5. c语音中的结构体内不能写函数。
6. 结构体可以作形参，也可以做实参。
7. 结构体指针表示内部变量的方法：
>p_pt->x;
8. 数据对齐：<br>
结构体内，任何变量的地址一定是自身大小的整数倍 **（double类型数据大小按4计算）。**<br>
数据对齐会造成结构体内部各部分之间有空隙。
9. 数据补齐：<br>
声明结构体的时候，把占地小的放在前面，占地大的放在后面，可以最大程度的节省内存空间。

# 7. 内存分配
## 7.1 malloc动态分配内存
分配的内存在堆中，生命周期由程序员管理：
>int* p_val = (int*)malloc(5*sizeof(int));<br>

动态分配内存有可能失败，所以在使用前，需要确认指针是否为NULL：
>if (p_val){}

## 7.2 free释放内存
动态分配的内存不及时释放会造成内存泄露，需要用free函数释放内存。
>if (p_val){<br>
free(p_val);<br>
p_val = NULL;<br>
}

# 8. 文件操作
1. 基本步骤：
    - 打开文件fopen
    >FILE *p_file = fopen("a.txt","w");<br>
    if (p_file){}
    - 操作文件fread/fwrite
    - 关闭文件fclose
    >if (p_file){<br>
    fclose(p_file);<br>
    p_file = NULL;<br>
    }
2. 文件打开方式：
    - "r" 只能查看不能修改，要求文件已经存在。
    - "r+" 比r多了修改功能。
    - "w" 只能修改不能查看，只能从文件头开始修改。如果文件不存在就创建文件，否则删除文件原有内容。
    - "w+" 比w多了查看文件内容功能。
    - "a" 只能修改不能查看，修改方式是在文件尾追加。如果文件不存在就创建文件，否则保留文件原有内容。
    - "a+" 比a多了查看功能。
    - "b" 以二进制方式操作文件。
3. 位置指针：
    - ftell 用来获得位置指针的数值。
    - rewind 把位置指针调整到文件开头。
    - fseek 可以把位置指针调整到文件中的任何地方。